/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.28.3
 * source: MarketData.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export enum Direction {
    BUY = 0,
    SELL = 1
}
export enum AccountType {
    TFSA = 0,
    NR = 1,
    FHSA = 2,
    RRSP = 3,
    IND = 4
}
export enum InstrumentType {
    EQUITY = 0,
    INDEX = 1,
    ETF = 2,
    MUTUALFUND = 3,
    FUTURE = 4,
    CURRENCY = 5,
    CRYPTOCURRENCY = 6,
    OPTION = 7
}
export class Ticker extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        symbol?: string;
        name?: string;
        sector?: string;
        type?: InstrumentType;
        data?: Value[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("symbol" in data && data.symbol != undefined) {
                this.symbol = data.symbol;
            }
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("sector" in data && data.sector != undefined) {
                this.sector = data.sector;
            }
            if ("type" in data && data.type != undefined) {
                this.type = data.type;
            }
            if ("data" in data && data.data != undefined) {
                this.data = data.data;
            }
        }
    }
    get symbol() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set symbol(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get sector() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set sector(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get type() {
        return pb_1.Message.getFieldWithDefault(this, 4, InstrumentType.EQUITY) as InstrumentType;
    }
    set type(value: InstrumentType) {
        pb_1.Message.setField(this, 4, value);
    }
    get data() {
        return pb_1.Message.getRepeatedWrapperField(this, Value, 5) as Value[];
    }
    set data(value: Value[]) {
        pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    static fromObject(data: {
        symbol?: string;
        name?: string;
        sector?: string;
        type?: InstrumentType;
        data?: ReturnType<typeof Value.prototype.toObject>[];
    }): Ticker {
        const message = new Ticker({});
        if (data.symbol != null) {
            message.symbol = data.symbol;
        }
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.sector != null) {
            message.sector = data.sector;
        }
        if (data.type != null) {
            message.type = data.type;
        }
        if (data.data != null) {
            message.data = data.data.map(item => Value.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            symbol?: string;
            name?: string;
            sector?: string;
            type?: InstrumentType;
            data?: ReturnType<typeof Value.prototype.toObject>[];
        } = {};
        if (this.symbol != null) {
            data.symbol = this.symbol;
        }
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.sector != null) {
            data.sector = this.sector;
        }
        if (this.type != null) {
            data.type = this.type;
        }
        if (this.data != null) {
            data.data = this.data.map((item: Value) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.symbol.length)
            writer.writeString(1, this.symbol);
        if (this.name.length)
            writer.writeString(2, this.name);
        if (this.sector.length)
            writer.writeString(3, this.sector);
        if (this.type != InstrumentType.EQUITY)
            writer.writeEnum(4, this.type);
        if (this.data.length)
            writer.writeRepeatedMessage(5, this.data, (item: Value) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Ticker {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Ticker();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.symbol = reader.readString();
                    break;
                case 2:
                    message.name = reader.readString();
                    break;
                case 3:
                    message.sector = reader.readString();
                    break;
                case 4:
                    message.type = reader.readEnum();
                    break;
                case 5:
                    reader.readMessage(message.data, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Value.deserialize(reader), Value));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Ticker {
        return Ticker.deserialize(bytes);
    }
}
export class Value extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        date?: number;
        price?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("date" in data && data.date != undefined) {
                this.date = data.date;
            }
            if ("price" in data && data.price != undefined) {
                this.price = data.price;
            }
        }
    }
    get date() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set date(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get price() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set price(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        date?: number;
        price?: number;
    }): Value {
        const message = new Value({});
        if (data.date != null) {
            message.date = data.date;
        }
        if (data.price != null) {
            message.price = data.price;
        }
        return message;
    }
    toObject() {
        const data: {
            date?: number;
            price?: number;
        } = {};
        if (this.date != null) {
            data.date = this.date;
        }
        if (this.price != null) {
            data.price = this.price;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.date != 0)
            writer.writeInt32(1, this.date);
        if (this.price != 0)
            writer.writeDouble(2, this.price);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Value {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Value();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.date = reader.readInt32();
                    break;
                case 2:
                    message.price = reader.readDouble();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Value {
        return Value.deserialize(bytes);
    }
}
/** @deprecated*/
export class Investment extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ticker?: Ticker;
        qty?: number;
        accountType?: AccountType;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ticker" in data && data.ticker != undefined) {
                this.ticker = data.ticker;
            }
            if ("qty" in data && data.qty != undefined) {
                this.qty = data.qty;
            }
            if ("accountType" in data && data.accountType != undefined) {
                this.accountType = data.accountType;
            }
        }
    }
    get ticker() {
        return pb_1.Message.getWrapperField(this, Ticker, 1) as Ticker;
    }
    set ticker(value: Ticker) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_ticker() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get qty() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set qty(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get accountType() {
        return pb_1.Message.getFieldWithDefault(this, 3, AccountType.TFSA) as AccountType;
    }
    set accountType(value: AccountType) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        ticker?: ReturnType<typeof Ticker.prototype.toObject>;
        qty?: number;
        accountType?: AccountType;
    }): Investment {
        const message = new Investment({});
        if (data.ticker != null) {
            message.ticker = Ticker.fromObject(data.ticker);
        }
        if (data.qty != null) {
            message.qty = data.qty;
        }
        if (data.accountType != null) {
            message.accountType = data.accountType;
        }
        return message;
    }
    toObject() {
        const data: {
            ticker?: ReturnType<typeof Ticker.prototype.toObject>;
            qty?: number;
            accountType?: AccountType;
        } = {};
        if (this.ticker != null) {
            data.ticker = this.ticker.toObject();
        }
        if (this.qty != null) {
            data.qty = this.qty;
        }
        if (this.accountType != null) {
            data.accountType = this.accountType;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_ticker)
            writer.writeMessage(1, this.ticker, () => this.ticker.serialize(writer));
        if (this.qty != 0)
            writer.writeDouble(2, this.qty);
        if (this.accountType != AccountType.TFSA)
            writer.writeEnum(3, this.accountType);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Investment {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Investment();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.ticker, () => message.ticker = Ticker.deserialize(reader));
                    break;
                case 2:
                    message.qty = reader.readDouble();
                    break;
                case 3:
                    message.accountType = reader.readEnum();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Investment {
        return Investment.deserialize(bytes);
    }
}
export class Instrument extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ticker?: Ticker;
        qty?: number;
        accountType?: AccountType;
        direction?: Direction;
        metaData?: Map<string, string>;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ticker" in data && data.ticker != undefined) {
                this.ticker = data.ticker;
            }
            if ("qty" in data && data.qty != undefined) {
                this.qty = data.qty;
            }
            if ("accountType" in data && data.accountType != undefined) {
                this.accountType = data.accountType;
            }
            if ("direction" in data && data.direction != undefined) {
                this.direction = data.direction;
            }
            if ("metaData" in data && data.metaData != undefined) {
                this.metaData = data.metaData;
            }
        }
        if (!this.metaData)
            this.metaData = new Map();
    }
    get ticker() {
        return pb_1.Message.getWrapperField(this, Ticker, 1) as Ticker;
    }
    set ticker(value: Ticker) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_ticker() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get qty() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set qty(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get accountType() {
        return pb_1.Message.getFieldWithDefault(this, 3, AccountType.TFSA) as AccountType;
    }
    set accountType(value: AccountType) {
        pb_1.Message.setField(this, 3, value);
    }
    get direction() {
        return pb_1.Message.getFieldWithDefault(this, 4, Direction.BUY) as Direction;
    }
    set direction(value: Direction) {
        pb_1.Message.setField(this, 4, value);
    }
    get metaData() {
        return pb_1.Message.getField(this, 5) as any as Map<string, string>;
    }
    set metaData(value: Map<string, string>) {
        pb_1.Message.setField(this, 5, value as any);
    }
    static fromObject(data: {
        ticker?: ReturnType<typeof Ticker.prototype.toObject>;
        qty?: number;
        accountType?: AccountType;
        direction?: Direction;
        metaData?: {
            [key: string]: string;
        };
    }): Instrument {
        const message = new Instrument({});
        if (data.ticker != null) {
            message.ticker = Ticker.fromObject(data.ticker);
        }
        if (data.qty != null) {
            message.qty = data.qty;
        }
        if (data.accountType != null) {
            message.accountType = data.accountType;
        }
        if (data.direction != null) {
            message.direction = data.direction;
        }
        if (typeof data.metaData == "object") {
            message.metaData = new Map(Object.entries(data.metaData));
        }
        return message;
    }
    toObject() {
        const data: {
            ticker?: ReturnType<typeof Ticker.prototype.toObject>;
            qty?: number;
            accountType?: AccountType;
            direction?: Direction;
            metaData?: {
                [key: string]: string;
            };
        } = {};
        if (this.ticker != null) {
            data.ticker = this.ticker.toObject();
        }
        if (this.qty != null) {
            data.qty = this.qty;
        }
        if (this.accountType != null) {
            data.accountType = this.accountType;
        }
        if (this.direction != null) {
            data.direction = this.direction;
        }
        if (this.metaData != null) {
            data.metaData = (Object.fromEntries)(this.metaData);
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_ticker)
            writer.writeMessage(1, this.ticker, () => this.ticker.serialize(writer));
        if (this.qty != 0)
            writer.writeDouble(2, this.qty);
        if (this.accountType != AccountType.TFSA)
            writer.writeEnum(3, this.accountType);
        if (this.direction != Direction.BUY)
            writer.writeEnum(4, this.direction);
        for (const [key, value] of this.metaData) {
            writer.writeMessage(5, this.metaData, () => {
                writer.writeString(1, key);
                writer.writeString(2, value);
            });
        }
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Instrument {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Instrument();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.ticker, () => message.ticker = Ticker.deserialize(reader));
                    break;
                case 2:
                    message.qty = reader.readDouble();
                    break;
                case 3:
                    message.accountType = reader.readEnum();
                    break;
                case 4:
                    message.direction = reader.readEnum();
                    break;
                case 5:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.metaData as any, reader, reader.readString, reader.readString));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Instrument {
        return Instrument.deserialize(bytes);
    }
}
export class Portfolio extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        /** @deprecated*/
        investments?: Investment[];
        instruments?: Instrument[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("investments" in data && data.investments != undefined) {
                this.investments = data.investments;
            }
            if ("instruments" in data && data.instruments != undefined) {
                this.instruments = data.instruments;
            }
        }
    }
    /** @deprecated*/
    get investments() {
        return pb_1.Message.getRepeatedWrapperField(this, Investment, 1) as Investment[];
    }
    /** @deprecated*/
    set investments(value: Investment[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get instruments() {
        return pb_1.Message.getRepeatedWrapperField(this, Instrument, 2) as Instrument[];
    }
    set instruments(value: Instrument[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
        investments?: ReturnType<typeof Investment.prototype.toObject>[];
        instruments?: ReturnType<typeof Instrument.prototype.toObject>[];
    }): Portfolio {
        const message = new Portfolio({});
        if (data.investments != null) {
            message.investments = data.investments.map(item => Investment.fromObject(item));
        }
        if (data.instruments != null) {
            message.instruments = data.instruments.map(item => Instrument.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            investments?: ReturnType<typeof Investment.prototype.toObject>[];
            instruments?: ReturnType<typeof Instrument.prototype.toObject>[];
        } = {};
        if (this.investments != null) {
            data.investments = this.investments.map((item: Investment) => item.toObject());
        }
        if (this.instruments != null) {
            data.instruments = this.instruments.map((item: Instrument) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.investments.length)
            writer.writeRepeatedMessage(1, this.investments, (item: Investment) => item.serialize(writer));
        if (this.instruments.length)
            writer.writeRepeatedMessage(2, this.instruments, (item: Instrument) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Portfolio {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Portfolio();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.investments, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Investment.deserialize(reader), Investment));
                    break;
                case 2:
                    reader.readMessage(message.instruments, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Instrument.deserialize(reader), Instrument));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Portfolio {
        return Portfolio.deserialize(bytes);
    }
}
