/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: ItemPricing.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";

export class ItemPricingRecord extends pb_1.Message {
  #one_of_decls: number[][] = [];

  constructor(data?: any[] | {
    date?: number;
    item?: string;
    quantity?: string;
    price?: number;
    source?: string;
    location?: string;
    category?: string;
    note?: string;
  }) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == "object") {
      if ("date" in data && data.date != undefined) {
        this.date = data.date;
      }
      if ("item" in data && data.item != undefined) {
        this.item = data.item;
      }
      if ("quantity" in data && data.quantity != undefined) {
        this.quantity = data.quantity;
      }
      if ("price" in data && data.price != undefined) {
        this.price = data.price;
      }
      if ("source" in data && data.source != undefined) {
        this.source = data.source;
      }
      if ("location" in data && data.location != undefined) {
        this.location = data.location;
      }
      if ("category" in data && data.category != undefined) {
        this.category = data.category;
      }
      if ("note" in data && data.note != undefined) {
        this.note = data.note;
      }
    }
  }

  get date() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }

  set date(value: number) {
    pb_1.Message.setField(this, 1, value);
  }

  get item() {
    return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
  }

  set item(value: string) {
    pb_1.Message.setField(this, 2, value);
  }

  get quantity() {
    return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
  }

  set quantity(value: string) {
    pb_1.Message.setField(this, 3, value);
  }

  get price() {
    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
  }

  set price(value: number) {
    pb_1.Message.setField(this, 4, value);
  }

  get source() {
    return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
  }

  set source(value: string) {
    pb_1.Message.setField(this, 5, value);
  }

  get location() {
    return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
  }

  set location(value: string) {
    pb_1.Message.setField(this, 6, value);
  }

  get category() {
    return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
  }

  set category(value: string) {
    pb_1.Message.setField(this, 7, value);
  }

  get note() {
    return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
  }

  set note(value: string) {
    pb_1.Message.setField(this, 8, value);
  }

  static fromObject(data: {
    date?: number;
    item?: string;
    quantity?: string;
    price?: number;
    source?: string;
    location?: string;
    category?: string;
    note?: string;
  }): ItemPricingRecord {
    const message = new ItemPricingRecord({});
    if (data.date != null) {
      message.date = data.date;
    }
    if (data.item != null) {
      message.item = data.item;
    }
    if (data.quantity != null) {
      message.quantity = data.quantity;
    }
    if (data.price != null) {
      message.price = data.price;
    }
    if (data.source != null) {
      message.source = data.source;
    }
    if (data.location != null) {
      message.location = data.location;
    }
    if (data.category != null) {
      message.category = data.category;
    }
    if (data.note != null) {
      message.note = data.note;
    }
    return message;
  }

  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ItemPricingRecord {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ItemPricingRecord();
    while (reader.nextField()) {
      if (reader.isEndGroup())
        break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.date = reader.readInt32();
          break;
        case 2:
          message.item = reader.readString();
          break;
        case 3:
          message.quantity = reader.readString();
          break;
        case 4:
          message.price = reader.readDouble();
          break;
        case 5:
          message.source = reader.readString();
          break;
        case 6:
          message.location = reader.readString();
          break;
        case 7:
          message.category = reader.readString();
          break;
        case 8:
          message.note = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }

  static deserializeBinary(bytes: Uint8Array): ItemPricingRecord {
    return ItemPricingRecord.deserialize(bytes);
  }

  toObject() {
    const data: {
      date?: number;
      item?: string;
      quantity?: string;
      price?: number;
      source?: string;
      location?: string;
      category?: string;
      note?: string;
    } = {};
    if (this.date != null) {
      data.date = this.date;
    }
    if (this.item != null) {
      data.item = this.item;
    }
    if (this.quantity != null) {
      data.quantity = this.quantity;
    }
    if (this.price != null) {
      data.price = this.price;
    }
    if (this.source != null) {
      data.source = this.source;
    }
    if (this.location != null) {
      data.location = this.location;
    }
    if (this.category != null) {
      data.category = this.category;
    }
    if (this.note != null) {
      data.note = this.note;
    }
    return data;
  }

  serialize(): Uint8Array;

  serialize(w: pb_1.BinaryWriter): void;

  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.date != 0)
      writer.writeInt32(1, this.date);
    if (this.item.length)
      writer.writeString(2, this.item);
    if (this.quantity.length)
      writer.writeString(3, this.quantity);
    if (this.price != 0)
      writer.writeDouble(4, this.price);
    if (this.source.length)
      writer.writeString(5, this.source);
    if (this.location.length)
      writer.writeString(6, this.location);
    if (this.category.length)
      writer.writeString(7, this.category);
    if (this.note.length)
      writer.writeString(8, this.note);
    if (!w)
      return writer.getResultBuffer();
  }

  serializeBinary(): Uint8Array {
    return this.serialize();
  }
}

export class ItemPricingStats extends pb_1.Message {
  #one_of_decls: number[][] = [];

  constructor(data?: any[] | {
    startDate?: number;
    endDate?: number;
    totalSpent?: number;
    categoryTotalPriceMap?: Map<string, number>;
    categoryExtraAggregateMap?: Map<string, number>;
    itemPricingRecords?: ItemPricingRecord[];
  }) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == "object") {
      if ("startDate" in data && data.startDate != undefined) {
        this.startDate = data.startDate;
      }
      if ("endDate" in data && data.endDate != undefined) {
        this.endDate = data.endDate;
      }
      if ("totalSpent" in data && data.totalSpent != undefined) {
        this.totalSpent = data.totalSpent;
      }
      if ("categoryTotalPriceMap" in data && data.categoryTotalPriceMap != undefined) {
        this.categoryTotalPriceMap = data.categoryTotalPriceMap;
      }
      if ("categoryExtraAggregateMap" in data && data.categoryExtraAggregateMap != undefined) {
        this.categoryExtraAggregateMap = data.categoryExtraAggregateMap;
      }
      if ("itemPricingRecords" in data && data.itemPricingRecords != undefined) {
        this.itemPricingRecords = data.itemPricingRecords;
      }
    }
    if (!this.categoryTotalPriceMap)
      this.categoryTotalPriceMap = new Map();
    if (!this.categoryExtraAggregateMap)
      this.categoryExtraAggregateMap = new Map();
  }

  get startDate() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }

  set startDate(value: number) {
    pb_1.Message.setField(this, 1, value);
  }

  get endDate() {
    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
  }

  set endDate(value: number) {
    pb_1.Message.setField(this, 2, value);
  }

  get totalSpent() {
    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
  }

  set totalSpent(value: number) {
    pb_1.Message.setField(this, 3, value);
  }

  get categoryTotalPriceMap() {
    return pb_1.Message.getField(this, 4) as any as Map<string, number>;
  }

  set categoryTotalPriceMap(value: Map<string, number>) {
    pb_1.Message.setField(this, 4, value as any);
  }

  get categoryExtraAggregateMap() {
    return pb_1.Message.getField(this, 5) as any as Map<string, number>;
  }

  set categoryExtraAggregateMap(value: Map<string, number>) {
    pb_1.Message.setField(this, 5, value as any);
  }

  get itemPricingRecords() {
    return pb_1.Message.getRepeatedWrapperField(this, ItemPricingRecord, 6) as ItemPricingRecord[];
  }

  set itemPricingRecords(value: ItemPricingRecord[]) {
    pb_1.Message.setRepeatedWrapperField(this, 6, value);
  }

  static fromObject(data: {
    startDate?: number;
    endDate?: number;
    totalSpent?: number;
    categoryTotalPriceMap?: {
      [key: string]: number;
    };
    categoryExtraAggregateMap?: {
      [key: string]: number;
    };
    itemPricingRecords?: ReturnType<typeof ItemPricingRecord.prototype.toObject>[];
  }): ItemPricingStats {
    const message = new ItemPricingStats({});
    if (data.startDate != null) {
      message.startDate = data.startDate;
    }
    if (data.endDate != null) {
      message.endDate = data.endDate;
    }
    if (data.totalSpent != null) {
      message.totalSpent = data.totalSpent;
    }
    if (typeof data.categoryTotalPriceMap == "object") {
      message.categoryTotalPriceMap = new Map(Object.entries(data.categoryTotalPriceMap));
    }
    if (typeof data.categoryExtraAggregateMap == "object") {
      message.categoryExtraAggregateMap = new Map(Object.entries(data.categoryExtraAggregateMap));
    }
    if (data.itemPricingRecords != null) {
      message.itemPricingRecords = data.itemPricingRecords.map(item => ItemPricingRecord.fromObject(item));
    }
    return message;
  }

  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ItemPricingStats {
    const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ItemPricingStats();
    while (reader.nextField()) {
      if (reader.isEndGroup())
        break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.startDate = reader.readInt32();
          break;
        case 2:
          message.endDate = reader.readInt32();
          break;
        case 3:
          message.totalSpent = reader.readDouble();
          break;
        case 4:
          reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.categoryTotalPriceMap as any, reader, reader.readString, reader.readDouble));
          break;
        case 5:
          reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.categoryExtraAggregateMap as any, reader, reader.readString, reader.readDouble));
          break;
        case 6:
          reader.readMessage(message.itemPricingRecords, () => pb_1.Message.addToRepeatedWrapperField(message, 6, ItemPricingRecord.deserialize(reader), ItemPricingRecord));
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }

  static deserializeBinary(bytes: Uint8Array): ItemPricingStats {
    return ItemPricingStats.deserialize(bytes);
  }

  toObject() {
    const data: {
      startDate?: number;
      endDate?: number;
      totalSpent?: number;
      categoryTotalPriceMap?: {
        [key: string]: number;
      };
      categoryExtraAggregateMap?: {
        [key: string]: number;
      };
      itemPricingRecords?: ReturnType<typeof ItemPricingRecord.prototype.toObject>[];
    } = {};
    if (this.startDate != null) {
      data.startDate = this.startDate;
    }
    if (this.endDate != null) {
      data.endDate = this.endDate;
    }
    if (this.totalSpent != null) {
      data.totalSpent = this.totalSpent;
    }
    if (this.categoryTotalPriceMap != null) {
      data.categoryTotalPriceMap = (Object.fromEntries)(this.categoryTotalPriceMap);
    }
    if (this.categoryExtraAggregateMap != null) {
      data.categoryExtraAggregateMap = (Object.fromEntries)(this.categoryExtraAggregateMap);
    }
    if (this.itemPricingRecords != null) {
      data.itemPricingRecords = this.itemPricingRecords.map((item: ItemPricingRecord) => item.toObject());
    }
    return data;
  }

  serialize(): Uint8Array;

  serialize(w: pb_1.BinaryWriter): void;

  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.startDate != 0)
      writer.writeInt32(1, this.startDate);
    if (this.endDate != 0)
      writer.writeInt32(2, this.endDate);
    if (this.totalSpent != 0)
      writer.writeDouble(3, this.totalSpent);
    for (const [key, value] of this.categoryTotalPriceMap) {
      writer.writeMessage(4, this.categoryTotalPriceMap, () => {
        writer.writeString(1, key);
        writer.writeDouble(2, value);
      });
    }
    for (const [key, value] of this.categoryExtraAggregateMap) {
      writer.writeMessage(5, this.categoryExtraAggregateMap, () => {
        writer.writeString(1, key);
        writer.writeDouble(2, value);
      });
    }
    if (this.itemPricingRecords.length)
      writer.writeRepeatedMessage(6, this.itemPricingRecords, (item: ItemPricingRecord) => item.serialize(writer));
    if (!w)
      return writer.getResultBuffer();
  }

  serializeBinary(): Uint8Array {
    return this.serialize();
  }
}
